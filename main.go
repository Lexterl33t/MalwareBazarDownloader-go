package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"os"

	"github.com/alexmullins/zip"
)

const API_URL = "https://mb-api.abuse.ch/api/v1/"
const ZIP_PASSWORD = "infected"

type TagInfos_t struct {
	QueryStatus string `json:"query_status"`
	Data        []Data_t
}

type Data_t struct {
	SHA256_hash string `json:"sha256_hash"`
}

func download_by_hash(sha256_hash string) {
	data := url.Values{
		"query":       {"get_file"},
		"sha256_hash": {sha256_hash},
	}

	resp, err := http.PostForm(API_URL, data)
	if err != nil {
		panic(err)
	}

	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		panic(err)
	}

	zipReader, err := zip.NewReader(bytes.NewReader(body), int64(len(body)))
	if err != nil {
		panic(err)
	}

	for _, file := range zipReader.File {
		if file.IsEncrypted() {
			file.SetPassword(ZIP_PASSWORD)
		}

		file_bytes, err := file.Open()
		if err != nil {
			panic(err)
		}

		bytes, err := ioutil.ReadAll(file_bytes)
		if err != nil {
			panic(err)
		}

		f, err := os.Create("output/" + file.Name)
		if err != nil {
			panic(err)
		}

		f.Write(bytes)
	}

}

func get_hashs_by_tag(tag string) TagInfos_t {

	data := url.Values{
		"query": {"get_taginfo"},
		"tag":   {tag},
	}

	resp, err := http.PostForm(API_URL, data)
	if err != nil {
		panic(err)
	}

	defer resp.Body.Close()

	var tag_info TagInfos_t
	json.NewDecoder(resp.Body).Decode(&tag_info)

	return tag_info

}

func main() {
	var tags []string = []string{
		"rust",
		"RustyStealer",
	}

	for _, tag := range tags {
		tag_infos := get_hashs_by_tag(tag)
		for _, data := range tag_infos.Data {
			fmt.Println("Downloading " + data.SHA256_hash + "...")
			download_by_hash(data.SHA256_hash)
		}
	}
}
